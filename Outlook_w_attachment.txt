import datetime as dt
from pathlib import Path
import win32com.client as win32
from win32com.client import constants


def find_email_by_subject(subject_text, since_days=30, folder="Inbox"):
    outlook = win32.gencache.EnsureDispatch("Outlook.Application")
    ns = outlook.GetNamespace("MAPI")

    # 6 = Inbox, 5 = Sent Items
    if folder.lower() in ("inbox",):
        root = ns.GetDefaultFolder(6)
    elif folder.lower() in ("sent", "sent items"):
        root = ns.GetDefaultFolder(5)
    else:
        root = ns.GetDefaultFolder(6)  # default to Inbox

    cutoff = (dt.datetime.now() - dt.timedelta(days=since_days)).strftime("%m/%d/%Y %I:%M %p")
    items = root.Items.Restrict(f"[ReceivedTime] >= '{cutoff}'")
    items.Sort("[ReceivedTime]", True)  # newest first

    subject_text = (subject_text or "").lower()

    for mail in items:
        if getattr(mail, "Class", None) == 43:  # 43 = MailItem
            if mail.Subject and subject_text in mail.Subject.lower():
                return mail

    return None


def reply_to_latest_email(
    subject_text,
    reply_message_html,
    reply_all=True,
    attachment_path=None,
    mark_confidential=True,
    display_instead_of_send=True,
):
    email = find_email_by_subject(subject_text)

    if email is None:
        raise RuntimeError(f"No email found with subject containing: {subject_text!r}")

    # Reply or ReplyAll
    reply = email.ReplyAll() if reply_all else email.Reply()

    # Prepend your message to the thread
    reply.HTMLBody = reply_message_html + reply.HTMLBody

    # Optional: mark as Confidential
    if mark_confidential:
        reply.Sensitivity = constants.olConfidential  # 3

    # Optional: add attachment
    if attachment_path:
        p = Path(attachment_path).expanduser().resolve()
        if not p.exists():
            raise FileNotFoundError(p)
        reply.Attachments.Add(str(p))

    # Either open for review or send directly
    if display_instead_of_send:
        reply.Display()
    else:
        reply.Send()

reply_to_latest_email(
    subject_text="Daily Fraud Trends",   # part of the subject
    reply_message_html="""
        <p>Hi team,<br><br>
        Please find attached todayâ€™s updated report in this thread.<br><br>
        Regards,<br>
        Nikhil
        </p>
    """,
    reply_all=True,
    attachment_path=r"C:\Users\hp\Downloads\Daily_Fraud_Trends_20251119.xlsx",
    mark_confidential=True,
    display_instead_of_send=True,  # change to False if you want auto-send
)



import os
import shutil
import win32com.client as win32

from win32com.client import gencache

# 1. Find path to gen_py cache
gen_path = gencache.GetGeneratePath()
print("gen_py path:", gen_path)

# 2. Delete the folder recursively
shutil.rmtree(gen_path, ignore_errors=True)
print("Deleted gen_py cache (if it existed).")


import win32com.client as win32

outlook = win32.gencache.EnsureDispatch("Outlook.Application")
ns = outlook.GetNamespace("MAPI")
print("Outlook connected, stores:", [f.Name for f in ns.Folders])

pip install --force-reinstall pywin32

import datetime as dt
import win32com.client as win32

OL_FOLDER_INBOX = 6
OL_MAIL_ITEM = 43

def find_latest_email_by_subject(snippet, since_days=30):
    outlook = win32.gencache.EnsureDispatch("Outlook.Application")
    ns = outlook.GetNamespace("MAPI")
    inbox = ns.GetDefaultFolder(OL_FOLDER_INBOX)

    cutoff = (dt.datetime.now() - dt.timedelta(days=since_days)).strftime("%m/%d/%Y %I:%M %p")
    items = inbox.Items.Restrict(f"[ReceivedTime] >= '{cutoff}'")
    items.Sort("[ReceivedTime]", True)  # newest first

    snippet = (snippet or "").lower()

    for item in items:
        if getattr(item, "Class", None) == OL_MAIL_ITEM:
            subj = item.Subject or ""
            if snippet in subj.lower():
                return item
    return None

def reply_plaintext_to_thread(subject_snippet, reply_text, reply_all=True):
    msg = find_latest_email_by_subject(subject_snippet)
    if msg is None:
        raise RuntimeError(f"No email found with subject containing: {subject_snippet!r}")

    # Reply in the same thread
    reply = msg.ReplyAll() if reply_all else msg.Reply()

    # Prepend your plain-text message, keep the chain below
    reply.Body = reply_text + "\n\n" + reply.Body

    # Show so you can review and send
    reply.Display()      # or reply.Send() to auto-send


# Example usage:
if __name__ == "__main__":
    reply_plaintext_to_thread(
        subject_snippet="Daily Fraud Trends",
        reply_text=(
            "Hi team,\n\n"
            "Here is today's update in this thread.\n"
            "Regards,\nNikhil"
        ),
        reply_all=True,
    )
